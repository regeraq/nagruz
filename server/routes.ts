import type { Express } from "express";
import express from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { hashPassword, verifyPassword, generateAccessToken, verifyAccessToken, generateRefreshToken } from "./auth";
import { insertContactSubmissionSchema, insertOrderSchema } from "@shared/schema";
import { z } from "zod";
import { 
  escapeHtml, 
  sanitizeInput, 
  calculateBase64Size, 
  isValidFileExtension, 
  isValidMimeType 
} from "./security";
import { rateLimiters } from "./rateLimiter";
import { cache, CACHE_TTL } from "./cache";
import { csrfProtection } from "./csrf";

const RESEND_API_KEY = process.env.RESEND_API_KEY;
const OWNER_EMAIL = process.env.OWNER_EMAIL || "owner@example.com";

// Constants
const MAX_FILE_SIZE_MB = 10;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
];
const ALLOWED_EXTENSIONS = ['.pdf', '.doc', '.docx', '.xls', '.xlsx'];
const API_TIMEOUT_MS = 10000; // 10 seconds

/**
 * FIXED: Email sending with timeout and better error handling
 */
async function sendEmail(to: string, subject: string, html: string) {
  if (!RESEND_API_KEY) {
    console.warn("RESEND_API_KEY not configured");
    return { success: false, message: "Email service not configured" };
  }

  try {
    // FIXED: Add timeout to prevent hanging requests
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${RESEND_API_KEY}`,
      },
      body: JSON.stringify({
        from: "onboarding@resend.dev",
        to,
        subject,
        html,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    const data = await response.json();
    console.log("Email sent:", { to, subject, success: response.ok, data });
    return { success: response.ok, data };
  } catch (error: any) {
    if (error.name === 'AbortError') {
      console.error("Email sending timeout");
      return { success: false, error: "Timeout" };
    }
    console.error("Error sending email:", error);
    return { success: false, error };
  }
}

/**
 * FIXED: Crypto rates with caching and timeout
 */
async function getCryptoRates(): Promise<{ btc: number; eth: number; usdt: number; ltc: number }> {
  // Check cache first
  const cacheKey = 'crypto-rates';
  const cached = cache.get<{ btc: number; eth: number; usdt: number; ltc: number }>(cacheKey);
  if (cached) {
    return cached;
  }

  try {
    // FIXED: Add timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

    const response = await fetch(
      'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,tether,litecoin&vs_currencies=rub',
      { signal: controller.signal }
    );

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`API returned ${response.status}`);
    }

    const data = await response.json();
    const rates = {
      btc: data.bitcoin?.rub || 0,
      eth: data.ethereum?.rub || 0,
      usdt: data.tether?.rub || 0,
      ltc: data.litecoin?.rub || 0,
    };

    // Cache the result
    cache.set(cacheKey, rates, CACHE_TTL.CRYPTO_RATES);

    return rates;
  } catch (error: any) {
    if (error.name === 'AbortError') {
      console.error("Crypto rates API timeout");
    } else {
      console.error("Error fetching crypto rates:", error);
    }
    
    // Return cached value if available, even if expired
    const staleCache = cache.get<{ btc: number; eth: number; usdt: number; ltc: number }>(cacheKey);
    if (staleCache) {
      return staleCache;
    }
    
    return { btc: 0, eth: 0, usdt: 0, ltc: 0 };
  }
}

export async function registerRoutes(app: Express): Promise<Server> {
  // CSRF token endpoint
  app.get("/api/csrf-token", (req, res) => {
    const token = res.locals.csrfToken;
    if (token) {
      res.json({ token });
    } else {
      // Token will be generated by csrfToken middleware
      res.json({ token: res.locals.csrfToken || "" });
    }
  });

  // Serve sitemap.xml for SEO
  app.get("/sitemap.xml", (req, res) => {
    res.setHeader('Content-Type', 'application/xml');
    res.sendFile('sitemap.xml', { root: './client/public' }, (err) => {
      if (err) {
        console.error('Error serving sitemap:', err);
        res.status(404).send('Sitemap not found');
      }
    });
  });

  // FIXED: Added rate limiting and caching
  app.get("/api/crypto-rates", rateLimiters.cryptoRates, async (req, res) => {
    try {
      const rates = await getCryptoRates();
      res.json(rates);
    } catch (error) {
      console.error("Error fetching crypto rates:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç",
      });
    }
  });
  // FIXED: Added rate limiting, authentication requirement, and input sanitization
  app.post("/api/contact", rateLimiters.contact, express.json({ limit: '15mb' }), async (req, res) => {
    try {
      // FIXED: Require authentication for contact submissions
      const token = req.headers.authorization?.replace("Bearer ", "");
      let userId: string | null = null;
      
      if (token) {
        try {
          const payload = verifyAccessToken(token);
          userId = payload.userId;
        } catch (e) {
          // Token invalid, userId stays null
        }
      }
      
      if (!userId) {
        res.status(401).json({
          success: false,
          message: "–î–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–æ–∫ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è",
        });
        return;
      }
      
      const validatedData = insertContactSubmissionSchema.parse(req.body);
      
      // FIXED: Validate and sanitize file data
      if (validatedData.fileData && validatedData.fileName) {
        const dataUrlMatch = validatedData.fileData.match(/^data:([^;]+);base64,(.+)$/);
        const base64Data = dataUrlMatch ? dataUrlMatch[2] : validatedData.fileData;
        const declaredMimeType = dataUrlMatch ? dataUrlMatch[1] : null;
        
        // FIXED: Accurate file size calculation
        const fileSizeBytes = calculateBase64Size(validatedData.fileData);
        const fileSizeMB = fileSizeBytes / (1024 * 1024);
        
        if (fileSizeMB > MAX_FILE_SIZE_MB) {
          res.status(413).json({
            success: false,
            message: `–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π (${MAX_FILE_SIZE_MB} –ú–ë)`,
          });
          return;
        }

        // FIXED: Validate MIME type
        if (declaredMimeType && !isValidMimeType(declaredMimeType, ALLOWED_MIME_TYPES)) {
          res.status(400).json({
            success: false,
            message: "–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PDF, DOC, DOCX, XLS, XLSX",
          });
          return;
        }

        // FIXED: Validate file extension
        if (!isValidFileExtension(validatedData.fileName, ALLOWED_EXTENSIONS)) {
          res.status(400).json({
            success: false,
            message: "–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PDF, DOC, DOCX, XLS, XLSX",
          });
          return;
        }
      }
      
      const submission = await storage.createContactSubmission(validatedData);
      
      // FIXED: XSS protection - escape all user input
      const ownerEmailHtml = `
        <h2>–ù–æ–≤–∞—è –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</h2>
        <p><strong>ID –∑–∞—è–≤–∫–∏:</strong> ${escapeHtml(submission.id)}</p>
        <p><strong>–ò–º—è:</strong> ${escapeHtml(validatedData.name)}</p>
        <p><strong>Email:</strong> ${escapeHtml(validatedData.email)}</p>
        <p><strong>–¢–µ–ª–µ—Ñ–æ–Ω:</strong> ${escapeHtml(validatedData.phone)}</p>
        <p><strong>–ö–æ–º–ø–∞–Ω–∏—è:</strong> ${escapeHtml(validatedData.company || '–ù–µ —É–∫–∞–∑–∞–Ω–∞')}</p>
        <p><strong>–°–æ–æ–±—â–µ–Ω–∏–µ:</strong></p>
        <p>${escapeHtml(validatedData.message).replace(/\n/g, '<br>')}</p>
        ${validatedData.fileName ? `<p><strong>–§–∞–π–ª:</strong> ${escapeHtml(validatedData.fileName)}</p>` : ''}
      `;

      // Send email asynchronously (don't block response)
      sendEmail(OWNER_EMAIL, `–ù–æ–≤–æ–µ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ (ID: ${submission.id}) –æ—Ç ${escapeHtml(validatedData.name)}`, ownerEmailHtml).catch(err => {
        console.error("Failed to send email:", err);
      });
      
      res.status(201).json({
        success: true,
        message: "–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à—É –∑–∞—è–≤–∫—É! –ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.",
        submissionId: submission.id,
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö",
          errors: error.errors,
        });
      } else {
        console.error("Error creating contact submission:", error);
        res.status(500).json({
          success: false,
          message: "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        });
      }
    }
  });

  app.get("/api/contact", rateLimiters.general, async (req, res) => {
    try {
      const submissions = await storage.getContactSubmissions();
      res.json(submissions);
    } catch (error) {
      console.error("Error fetching contact submissions:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞—è–≤–æ–∫",
      });
    }
  });

  app.get("/api/contact/:id", rateLimiters.general, async (req, res) => {
    try {
      const submission = await storage.getContactSubmission(req.params.id);
      
      if (!submission) {
        res.status(404).json({
          success: false,
          message: "–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
        });
        return;
      }
      
      res.json(submission);
    } catch (error) {
      console.error("Error fetching contact submission:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞—è–≤–∫–∏",
      });
    }
  });

  // FIXED: Added caching for products - only returns active products for customers
  app.get("/api/products", rateLimiters.general, async (req, res) => {
    try {
      const cacheKey = 'products-active';
      let products = cache.get(cacheKey);
      
      if (!products) {
        console.log(`üì¶ [GET /api/products] Cache miss, fetching from DB`);
        const allProducts = await storage.getProducts();
        console.log(`üì¶ [GET /api/products] Got ${allProducts.length} total products from DB`);
        
        products = allProducts.filter((p: any) => p.isActive !== false).map((p: any) => {
          const parsedImages = p.images ? (typeof p.images === 'string' ? JSON.parse(p.images) : p.images) : [];
          console.log(`üì∏ [GET /api/products] Product ${p.id}: ${parsedImages.length} images found in DB`);
          return {
            ...p,
            images: parsedImages
          };
        });
        
        console.log(`‚úÖ [GET /api/products] Parsed ${products.length} active products, setting cache`);
        cache.set(cacheKey, products, CACHE_TTL.PRODUCTS);
      } else {
        console.log(`‚ö° [GET /api/products] Using cached products (${products.length} items)`);
      }
      
      res.json(products);
    } catch (error) {
      console.error("‚ùå Error fetching products:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤",
      });
    }
  });

  // Admin: Get all products (including inactive)
  app.get("/api/admin/products", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const products = await storage.getProducts();
      const parsedProducts = products.map((p: any) => ({
        ...p,
        images: p.images ? (typeof p.images === 'string' ? JSON.parse(p.images) : p.images) : []
      }));
      res.json({ success: true, products: parsedProducts });
    } catch (error) {
      console.error("Error fetching all products:", error);
      res.status(500).json({ success: false, message: "Failed to fetch products" });
    }
  });

  app.get("/api/products/:id", rateLimiters.general, async (req, res) => {
    try {
      const product = await storage.getProduct(req.params.id);
      
      if (!product) {
        res.status(404).json({
          success: false,
          message: "–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω",
        });
        return;
      }
      
      const parsedProduct = {
        ...product,
        images: product.images ? (typeof product.images === 'string' ? JSON.parse(product.images) : product.images) : []
      };
      
      res.json(parsedProduct);
    } catch (error) {
      console.error("Error fetching product:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞",
      });
    }
  });

  // FIXED: Added rate limiting and CSRF protection for promo validation
  app.post("/api/promo/validate", csrfProtection, rateLimiters.promo, async (req, res) => {
    try {
      const { code } = req.body;
      
      if (!code || typeof code !== 'string') {
        res.status(400).json({
          success: false,
          message: "–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ —É–∫–∞–∑–∞–Ω",
        });
        return;
      }
      
      // FIXED: Sanitize input
      const sanitizedCode = sanitizeInput(code, 50);
      
      const promo = { valid: false, discount: 0, code: code, discountPercent: 0 }; // await storage.validatePromoCode(sanitizedCode);
      
      if (!promo) {
        res.status(404).json({
          success: false,
          message: "–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∏–ª–∏ –∏—Å—Ç–µ–∫",
        });
        return;
      }
      
      res.json({
        success: true,
        discountPercent: promo.discountPercent,
        code: promo.code,
      });
    } catch (error) {
      console.error("Error validating promo code:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞",
      });
    }
  });

  // FIXED: Added rate limiting and XSS protection (CSRF disabled for stateless REST API)
  app.post("/api/orders", rateLimiters.orders, async (req, res) => {
    try {
      // FIXED: Require authentication for orders
      const token = req.headers.authorization?.replace("Bearer ", "");
      let userId: string | null = null;
      
      if (token) {
        try {
          const payload = verifyAccessToken(token);
          userId = payload.userId;
        } catch (e) {
          // Token invalid, userId stays null
        }
      }
      
      if (!userId) {
        res.status(401).json({
          success: false,
          message: "–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è",
        });
        return;
      }
      
      const validatedData = insertOrderSchema.parse(req.body);
      
      // FIXED: Add userId to order
      const orderDataWithUserId = {
        ...validatedData,
        userId,
      };
      
      const product = await storage.getProduct(orderDataWithUserId.productId);
      if (!product) {
        res.status(404).json({
          success: false,
          message: "–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω",
        });
        return;
      }

      // FIXED: Check if enough stock available
      if (product.stock < orderDataWithUserId.quantity) {
        res.status(400).json({
          success: false,
          message: `–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–≤–∞—Ä–∞ –Ω–∞ —Å–∫–ª–∞–¥–µ. –î–æ—Å—Ç—É–ø–Ω–æ: ${product.stock} —à—Ç.`,
        });
        return;
      }

      // FIXED: Use UTC for consistent timezone handling
      const reservedUntil = new Date();
      reservedUntil.setUTCMinutes(reservedUntil.getUTCMinutes() + 15);

      const orderData = {
        ...orderDataWithUserId,
        reservedUntil,
      };

      const order = await storage.createOrder(orderData);
      
      // Clear cache after order to show updated stock
      cache.delete('products');
      cache.delete('products-active');
      
      // FIXED: Refresh product data after order creation to get updated stock
      const updatedProduct = await storage.getProduct(orderDataWithUserId.productId);
      
      // FIXED: Send notification to admins if product is out of stock
      if (updatedProduct && updatedProduct.stock === 0) {
        const outOfStockHtml = `
          <div style="font-family: Arial, sans-serif; color: #333; background: #fff3cd; padding: 20px; border-radius: 5px;">
            <h2 style="color: #d0461e; border-bottom: 2px solid #d0461e; padding-bottom: 10px;">‚ö†Ô∏è –¢–û–í–ê–† –ü–û–õ–ù–û–°–¢–¨–Æ –†–ê–°–ü–†–û–î–ê–ù</h2>
            
            <div style="background: #fff; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #d0461e;">
              <p style="margin: 5px 0;"><strong>–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞:</strong> ${escapeHtml(updatedProduct.name)}</p>
              <p style="margin: 5px 0;"><strong>–ê—Ä—Ç–∏–∫—É–ª:</strong> ${escapeHtml(updatedProduct.sku)}</p>
              <p style="margin: 5px 0;"><strong>–ú–æ–¥–µ–ª—å:</strong> ${escapeHtml(updatedProduct.id)}</p>
            </div>
            
            <p style="margin: 15px 0; color: #666;">–¢–æ–≤–∞—Ä –±—ã–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞—Å–ø—Ä–æ–¥–∞–Ω –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –∑–∞–∫–∞–∑–∞ <strong>#${escapeHtml(order.id)}</strong></p>
            
            <p style="margin-top: 20px; color: #666; font-size: 12px;">
              –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –ø–æ–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø–∞—Å—ã –∏–ª–∏ –æ—Ç–º–µ—Ç–∏—Ç—å —Ç–æ–≤–∞—Ä –∫–∞–∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–π –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.
            </p>
          </div>
        `;
        
        sendEmail(OWNER_EMAIL, `‚ö†Ô∏è –¢–û–í–ê–† –ó–ê–ö–û–ù–ß–ò–õ–°–Ø: ${escapeHtml(updatedProduct.name)} (${escapeHtml(updatedProduct.sku)})`, outOfStockHtml).catch(err => {
          console.error("Failed to send out of stock email:", err);
        });
      }

      // FIXED: XSS protection - escape all user input in email
      const ownerEmailHtml = `
        <div style="font-family: Arial, sans-serif; color: #333;">
          <h2 style="color: #1a1a1a; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">–ù–æ–≤—ã–π –∑–∞–∫–∞–∑</h2>
          
          <div style="background: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
            <p style="margin: 5px 0;"><strong>ID –∑–∞–∫–∞–∑–∞:</strong> <code style="background: #eee; padding: 3px 6px;">${escapeHtml(order.id)}</code></p>
            <p style="margin: 5px 0;"><strong>ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</strong> <code style="background: #eee; padding: 3px 6px;">${escapeHtml(order.userId || '–ì–æ—Å—Ç—å')}</code></p>
          </div>
          
          <h3 style="color: #1a1a1a; margin-top: 20px;">–ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç–∞:</h3>
          <ul style="list-style: none; padding: 0;">
            <li style="padding: 5px 0;"><strong>–ò–º—è:</strong> ${escapeHtml(order.customerName || '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</li>
            <li style="padding: 5px 0;"><strong>Email:</strong> ${escapeHtml(order.customerEmail || '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</li>
            <li style="padding: 5px 0;"><strong>–¢–µ–ª–µ—Ñ–æ–Ω:</strong> ${escapeHtml(order.customerPhone || '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</li>
          </ul>
          
          <h3 style="color: #1a1a1a; margin-top: 20px;">–î–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞:</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr style="background: #f0f0f0;">
              <td style="padding: 8px; border: 1px solid #ddd;"><strong>–ü–∞—Ä–∞–º–µ—Ç—Ä</strong></td>
              <td style="padding: 8px; border: 1px solid #ddd;"><strong>–ó–Ω–∞—á–µ–Ω–∏–µ</strong></td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd;">–¢–æ–≤–∞—Ä</td>
              <td style="padding: 8px; border: 1px solid #ddd;">${escapeHtml(product.name)}</td>
            </tr>
            <tr style="background: #fafafa;">
              <td style="padding: 8px; border: 1px solid #ddd;">–ê—Ä—Ç–∏–∫—É–ª</td>
              <td style="padding: 8px; border: 1px solid #ddd;">${escapeHtml(product.sku)}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd;">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ</td>
              <td style="padding: 8px; border: 1px solid #ddd;">${order.quantity} —à—Ç.</td>
            </tr>
            <tr style="background: #fafafa;">
              <td style="padding: 8px; border: 1px solid #ddd;">–°—É–º–º–∞</td>
              <td style="padding: 8px; border: 1px solid #ddd;"><strong>${escapeHtml(order.finalAmount)} –†–£–ë</strong></td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd;">–°–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã</td>
              <td style="padding: 8px; border: 1px solid #ddd;">${escapeHtml(order.paymentMethod)}</td>
            </tr>
            <tr style="background: #fafafa;">
              <td style="padding: 8px; border: 1px solid #ddd;">–°—Ç–∞—Ç—É—Å</td>
              <td style="padding: 8px; border: 1px solid #ddd;">${escapeHtml(order.paymentStatus)}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border: 1px solid #ddd;">–†–µ–∑–µ—Ä–≤–∞—Ü–∏—è –¥–æ</td>
              <td style="padding: 8px; border: 1px solid #ddd;">${order.reservedUntil ? new Date(order.reservedUntil).toLocaleString('ru-RU') : '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ'}</td>
            </tr>
          </table>
          
          <p style="margin-top: 20px; color: #666; font-size: 12px;">
            –≠—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–∏—Å—å–º–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º –ø–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–º –∫–æ–Ω—Ç–∞–∫—Ç–Ω—ã–º –¥–∞–Ω–Ω—ã–º.
          </p>
        </div>
      `;

      // Send email asynchronously
      sendEmail(OWNER_EMAIL, `–ù–æ–≤—ã–π –∑–∞–∫–∞–∑ #${escapeHtml(order.id)}`, ownerEmailHtml).catch(err => {
        console.error("Failed to send email:", err);
      });
      
      res.status(201).json({
        success: true,
        message: "–ó–∞–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω",
        order,
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö",
          errors: error.errors,
        });
      } else {
        console.error("Error creating order:", error);
        res.status(500).json({
          success: false,
          message: "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–∫–∞–∑–∞",
        });
      }
    }
  });

  // Get user orders (must be BEFORE /api/orders/:id)
  app.get("/api/orders/user", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const orders = await storage.getUserOrders(payload.userId);
      const ordersWithProducts = await Promise.all(
        orders.map(async (o: any) => ({
          ...o,
          product: await storage.getProduct(o.productId),
        }))
      );

      res.json(ordersWithProducts);
    } catch (error) {
      console.error("Get user orders error:", error);
      res.status(500).json({ success: false, message: "Failed to get orders" });
    }
  });

  // Admin: Get all orders (must be BEFORE /api/orders/:id)
  app.get("/api/admin/orders", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const orders = await storage.getAllOrders();
      res.json({ success: true, orders });
    } catch (error) {
      console.error("Get admin orders error:", error);
      res.status(500).json({ success: false, message: "Failed to get orders" });
    }
  });

  app.get("/api/orders/:id", rateLimiters.general, async (req, res) => {
    try {
      const order = await storage.getOrder(req.params.id);
      
      if (!order) {
        res.status(404).json({
          success: false,
          message: "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω",
        });
        return;
      }
      
      res.json(order);
    } catch (error) {
      console.error("Error fetching order:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞",
      });
    }
  });

  app.patch("/api/orders/:id/status", rateLimiters.general, async (req, res) => {
    try {
      const { status, paymentDetails } = req.body;
      
      if (!status || typeof status !== 'string') {
        res.status(400).json({
          success: false,
          message: "–°—Ç–∞—Ç—É—Å –Ω–µ —É–∫–∞–∑–∞–Ω",
        });
        return;
      }

      // FIXED: Sanitize input
      const sanitizedStatus = sanitizeInput(status, 50);
      const sanitizedPaymentDetails = paymentDetails ? sanitizeInput(paymentDetails, 1000) : undefined;

      const order = await storage.updateOrderStatus(req.params.id, sanitizedStatus, sanitizedPaymentDetails);
      
      if (!order) {
        res.status(404).json({
          success: false,
          message: "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω",
        });
        return;
      }
      
      res.json({
        success: true,
        message: "–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω",
        order,
      });
    } catch (error) {
      console.error("Error updating order status:", error);
      res.status(500).json({
        success: false,
        message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞",
      });
    }
  });


  // Auth endpoints
  app.post("/api/auth/register", rateLimiters.general, async (req, res) => {
    try {
      const { email, password, firstName, lastName, phone } = req.body;
      
      if (!email || !password) {
        res.status(400).json({ success: false, message: "Email and password required" });
        return;
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        res.status(409).json({ success: false, message: "User already exists" });
        return;
      }

      const hashedPassword = await hashPassword(password);
      const user = await storage.createUser({
        email,
        passwordHash: hashedPassword,
        firstName: firstName || null,
        lastName: lastName || null,
        phone: phone || null,
        role: "user",
      });

      const accessToken = generateAccessToken({
        userId: user.id,
        email: user.email,
        role: user.role,
      });

      const refreshToken = generateRefreshToken(user.id);

      res.json({
        success: true,
        message: "User registered successfully",
        user: { id: user.id, email: user.email, role: user.role },
        tokens: { accessToken, refreshToken },
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ success: false, message: "Registration failed" });
    }
  });

  app.post("/api/auth/login", rateLimiters.general, async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        res.status(400).json({ success: false, message: "Email and password required" });
        return;
      }

      const user = await storage.getUserByEmail(email);
      if (!user) {
        res.status(401).json({ success: false, message: "Invalid credentials" });
        return;
      }

      const passwordHash = user.passwordHash || user.password;
      const isPasswordValid = await verifyPassword(password, passwordHash);
      if (!isPasswordValid) {
        res.status(401).json({ success: false, message: "Invalid credentials" });
        return;
      }

      const accessToken = generateAccessToken({
        userId: user.id,
        email: user.email,
        role: user.role,
      });

      const refreshToken = generateRefreshToken(user.id);

      res.json({
        success: true,
        message: "Login successful",
        user: { id: user.id, email: user.email, role: user.role },
        tokens: { accessToken, refreshToken },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ success: false, message: "Login failed" });
    }
  });

  app.get("/api/auth/me", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "No token" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      res.json({
        success: true,
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          phone: user.phone,
          role: user.role,
          avatar: user.avatar,
          isEmailVerified: user.isEmailVerified || false,
          isPhoneVerified: user.isPhoneVerified || false,
          createdAt: user.createdAt || new Date().toISOString(),
        },
      });
    } catch (error) {
      console.error("Auth me error:", error);
      res.status(500).json({ success: false, message: "Failed to get user" });
    }
  });

  app.post("/api/auth/logout", rateLimiters.general, (req, res) => {
    res.json({ success: true, message: "Logged out" });
  });

  // Profile update endpoint
  app.patch("/api/auth/profile", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      const { firstName, lastName, phone } = req.body;
      
      // Update user in storage
      const updatedUser = await storage.updateUser(payload.userId, { firstName, lastName, phone });
      
      if (!updatedUser) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      res.json({
        success: true,
        user: {
          id: updatedUser.id,
          email: updatedUser.email,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          phone: updatedUser.phone,
          role: updatedUser.role,
          avatar: updatedUser.avatar,
          isEmailVerified: updatedUser.isEmailVerified || false,
          isPhoneVerified: updatedUser.isPhoneVerified || false,
          createdAt: updatedUser.createdAt || new Date().toISOString(),
        },
      });
    } catch (error) {
      console.error("Profile update error:", error);
      res.status(500).json({ success: false, message: "Failed to update profile" });
    }
  });


  // Admin: Update product stock
  app.patch("/api/admin/products/:id/stock", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const product = await storage.getProduct(req.params.id);
      if (!product) {
        res.status(404).json({ success: false, message: "Product not found" });
        return;
      }

      const { stock } = req.body;
      if (typeof stock !== "number") {
        res.status(400).json({ success: false, message: "Invalid stock value" });
        return;
      }

      product.stock = stock;

      res.json({
        success: true,
        product,
      });
    } catch (error) {
      console.error("Update stock error:", error);
      res.status(500).json({ success: false, message: "Failed to update stock" });
    }
  });

  // Admin: Delete products
  app.delete("/api/admin/products", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { ids } = req.body;
      if (!Array.isArray(ids)) {
        res.status(400).json({ success: false, message: "Invalid request" });
        return;
      }

      res.json({
        success: true,
        deleted: ids.length,
      });
    } catch (error) {
      console.error("Delete products error:", error);
      res.status(500).json({ success: false, message: "Failed to delete products" });
    }
  });

  // Admin: Update order status
  app.patch("/api/admin/orders/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { paymentStatus } = req.body;
      const order = await storage.updateOrderStatus(req.params.id, paymentStatus);
      
      if (!order) {
        res.status(404).json({ success: false, message: "Order not found" });
        return;
      }

      // Send notification and email to user if order status changed
      if (order.userId) {
        const orderUser = await storage.getUserById(order.userId);
        if (orderUser) {
          const statusMessages: Record<string, string> = {
            pending: "–û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã",
            paid: "–û–ø–ª–∞—á–µ–Ω",
            processing: "–í –æ–±—Ä–∞–±–æ—Ç–∫–µ",
            shipped: "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω",
            delivered: "–î–æ—Å—Ç–∞–≤–ª–µ–Ω",
            cancelled: "–û—Ç–º–µ–Ω–µ–Ω",
          };

          const statusMessage = statusMessages[paymentStatus] || paymentStatus;
          const notification = await storage.sendNotificationToUser(order.userId, {
            title: "–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –∏–∑–º–µ–Ω–µ–Ω",
            message: `–°—Ç–∞—Ç—É—Å –≤–∞—à–µ–≥–æ –∑–∞–∫–∞–∑–∞ #${order.id.slice(0, 8)} –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: ${statusMessage}`,
            type: paymentStatus === "cancelled" ? "error" : paymentStatus === "delivered" ? "success" : "info",
            link: `/profile`,
          });

          // Send email notification
          if (orderUser.email) {
            const emailHtml = `
              <div style="font-family: Arial, sans-serif; color: #333;">
                <h2 style="color: #1a1a1a; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ –∏–∑–º–µ–Ω–µ–Ω</h2>
                <p style="margin: 15px 0;"><strong>–ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞:</strong> #${escapeHtml(order.id.slice(0, 8))}</p>
                <p style="margin: 15px 0;"><strong>–ù–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å:</strong> ${escapeHtml(statusMessage)}</p>
                <p style="margin: 15px 0; line-height: 1.6;">–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞ –≤ —Å–≤–æ–µ–º –ø—Ä–æ—Ñ–∏–ª–µ –Ω–∞ —Å–∞–π—Ç–µ.</p>
                <p style="margin-top: 20px;"><a href="${process.env.FRONTEND_URL || 'http://localhost:5000'}/profile" style="color: #4CAF50; text-decoration: none;">–ü–µ—Ä–µ–π—Ç–∏ –≤ –ø—Ä–æ—Ñ–∏–ª—å ‚Üí</a></p>
              </div>
            `;
            sendEmail(orderUser.email, `–°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ #${order.id.slice(0, 8)} –∏–∑–º–µ–Ω–µ–Ω`, emailHtml).catch(err => {
              console.error("Failed to send order status email:", err);
            });
          }
        }
      }
      
      res.json({ success: true, order });
    } catch (error) {
      console.error("Update order status error:", error);
      res.status(500).json({ success: false, message: "Failed to update order" });
    }
  });

  // Add to favorites
  app.post("/api/favorites", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const { productId } = req.body;
      const favorite = await storage.addToFavorites(payload.userId, productId);

      if (!favorite) {
        res.status(404).json({ success: false, message: "Product not found" });
        return;
      }

      res.json({ success: true, favorite });
    } catch (error) {
      console.error("Add to favorites error:", error);
      res.status(500).json({ success: false, message: "Failed to add to favorites" });
    }
  });

  // Get user favorites
  app.get("/api/favorites", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const favorites = await storage.getUserFavorites(payload.userId);
      res.json(favorites);
    } catch (error) {
      console.error("Get favorites error:", error);
      res.status(500).json({ success: false, message: "Failed to get favorites" });
    }
  });

  // Remove from favorites
  app.delete("/api/favorites/:productId", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const deleted = await storage.removeFavorite(payload.userId, req.params.productId);
      res.json({ success: deleted });
    } catch (error) {
      console.error("Remove favorite error:", error);
      res.status(500).json({ success: false, message: "Failed to remove favorite" });
    }
  });

  // Get user notifications
  app.get("/api/notifications", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const notifications = await storage.getAllNotifications(payload.userId);
      res.json(notifications);
    } catch (error) {
      console.error("Get notifications error:", error);
      res.status(500).json({ success: false, message: "Failed to get notifications" });
    }
  });

  // Delete notification
  app.delete("/api/notifications/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const deleted = await storage.deleteNotification(req.params.id);
      res.json({ success: deleted });
    } catch (error) {
      console.error("Delete notification error:", error);
      res.status(500).json({ success: false, message: "Failed to delete notification" });
    }
  });

  // Clear all notifications
  app.post("/api/notifications/clear", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      await storage.clearUserNotifications(payload.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Clear notifications error:", error);
      res.status(500).json({ success: false, message: "Failed to clear notifications" });
    }
  });

  // Admin: Get user by ID with orders
  app.get("/api/admin/users/:userId", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const admin = await storage.getUserById(payload.userId);
      if (!admin || (admin.role !== "admin" && admin.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const user = await storage.getUserById(req.params.userId);
      if (!user) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      const orders = await storage.getUserOrders(req.params.userId);
      res.json({ user, orders });
    } catch (error) {
      console.error("Get user details error:", error);
      res.status(500).json({ success: false, message: "Failed to get user details" });
    }
  });

  // Admin: Get order details
  app.get("/api/admin/orders/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const order = await storage.getOrder(req.params.id);
      if (!order) {
        res.status(404).json({ success: false, message: "Order not found" });
        return;
      }

      const product = await storage.getProduct(order.productId);
      const orderUser = order.userId ? await storage.getUserById(order.userId) : null;

      res.json({ order, product, user: orderUser });
    } catch (error) {
      console.error("Get order details error:", error);
      res.status(500).json({ success: false, message: "Failed to get order details" });
    }
  });

  // Admin: Update product price
  app.patch("/api/admin/products/:id/price", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const product = await storage.updateProductPrice(req.params.id, req.body.price);
      if (!product) {
        res.status(404).json({ success: false, message: "Product not found" });
        return;
      }

      res.json({ success: true, product });
    } catch (error) {
      console.error("Update price error:", error);
      res.status(500).json({ success: false, message: "Failed to update price" });
    }
  });

  // Admin: Update product info
  app.patch("/api/admin/products/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const product = await storage.updateProductInfo(req.params.id, req.body);
      if (!product) {
        res.status(404).json({ success: false, message: "Product not found" });
        return;
      }

      // Clear product caches
      cache.delete('products');
      cache.delete('products-active');

      res.json({ success: true, product });
    } catch (error) {
      console.error("Update product error:", error);
      res.status(500).json({ success: false, message: "Failed to update product" });
    }
  });

  // Admin: Get admin dashboard stats
  app.get("/api/admin/stats", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const orders = await storage.getAllOrders();
      const contacts = await storage.getContactSubmissions();
      const users = Array.from((storage as any).users.values());
      
      res.json({
        success: true,
        stats: {
          totalUsers: users.length,
          totalOrders: orders.length,
          totalContacts: contacts.length,
          pendingOrders: orders.filter((o: any) => o.paymentStatus === 'pending').length,
        }
      });
    } catch (error) {
      console.error("Error fetching stats:", error);
      res.status(500).json({ success: false, message: "Failed to fetch stats" });
    }
  });

  // ADMIN: Create Product
  app.post("/api/admin/products", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      if (!payload) {
        res.status(401).json({ success: false, message: "Invalid token" });
        return;
      }

      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const product = await storage.createProduct(req.body);
      res.status(201).json({ success: true, product });
    } catch (error) {
      console.error("Create product error:", error);
      res.status(500).json({ success: false, message: "Failed to create product" });
    }
  });

  // ADMIN: Delete Products
  app.delete("/api/admin/products", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { ids } = req.body;
      if (!ids || !Array.isArray(ids)) {
        res.status(400).json({ success: false, message: "Invalid product IDs" });
        return;
      }

      const deleted = await storage.deleteProducts(ids);
      res.json({ success: true, deleted });
    } catch (error) {
      console.error("Delete products error:", error);
      res.status(500).json({ success: false, message: "Failed to delete products" });
    }
  });

  // ADMIN: Get All Users
  app.get("/api/admin/users", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const users = await storage.getAllUsers();
      res.json({ success: true, users });
    } catch (error) {
      console.error("Get users error:", error);
      res.status(500).json({ success: false, message: "Failed to get users" });
    }
  });

  // ADMIN: Get User by ID
  app.get("/api/admin/users/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const targetUser = await storage.getUserById(req.params.id);
      if (!targetUser) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      res.json({ success: true, user: targetUser });
    } catch (error) {
      console.error("Get user error:", error);
      res.status(500).json({ success: false, message: "Failed to get user" });
    }
  });

  // ADMIN: Update User Role
  app.patch("/api/admin/users/:id/role", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || user.role !== "superadmin") {
        res.status(403).json({ success: false, message: "Only superadmin can change roles" });
        return;
      }

      const { role } = req.body;
      if (!["user", "moderator", "admin", "superadmin"].includes(role)) {
        res.status(400).json({ success: false, message: "Invalid role" });
        return;
      }

      const updatedUser = await storage.updateUserRole(req.params.id, role);
      if (!updatedUser) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      res.json({ success: true, user: updatedUser });
    } catch (error) {
      console.error("Update role error:", error);
      res.status(500).json({ success: false, message: "Failed to update role" });
    }
  });

  // ADMIN: Block/Unblock User
  app.patch("/api/admin/users/:id/block", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { blocked } = req.body;
      const updatedUser = await storage.blockUser(req.params.id, blocked);
      if (!updatedUser) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      res.json({ success: true, user: updatedUser });
    } catch (error) {
      console.error("Block user error:", error);
      res.status(500).json({ success: false, message: "Failed to block user" });
    }
  });

  // ADMIN: Delete User
  app.delete("/api/admin/users/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || user.role !== "superadmin") {
        res.status(403).json({ success: false, message: "Only superadmin can delete users" });
        return;
      }

      const deleted = await storage.deleteUser(req.params.id);
      if (!deleted) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      res.json({ success: true, message: "User deleted" });
    } catch (error) {
      console.error("Delete user error:", error);
      res.status(500).json({ success: false, message: "Failed to delete user" });
    }
  });

  // ADMIN: Get User Orders
  app.get("/api/admin/users/:id/orders", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const orders = await storage.getUserOrders(req.params.id);
      res.json({ success: true, orders });
    } catch (error) {
      console.error("Get user orders error:", error);
      res.status(500).json({ success: false, message: "Failed to get orders" });
    }
  });

  // ADMIN: Create Admin User
  app.post("/api/admin/admins", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || user.role !== "superadmin") {
        res.status(403).json({ success: false, message: "Only superadmin can create admins" });
        return;
      }

      const { email, password, role, firstName, lastName } = req.body;
      
      if (!email || !password) {
        res.status(400).json({ success: false, message: "Email and password required" });
        return;
      }

      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        res.status(409).json({ success: false, message: "User already exists" });
        return;
      }

      const hashedPassword = await hashPassword(password);
      const newAdmin = await storage.createUser({
        email,
        password: hashedPassword,
        role: role || "admin",
        firstName: firstName || null,
        lastName: lastName || null,
      });

      res.status(201).json({ success: true, admin: newAdmin });
    } catch (error) {
      console.error("Create admin error:", error);
      res.status(500).json({ success: false, message: "Failed to create admin" });
    }
  });

  // ADMIN: Get Contact Submissions
  app.get("/api/admin/contacts", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const contacts = await storage.getContactSubmissions();
      res.json({ success: true, contacts });
    } catch (error) {
      console.error("Get contacts error:", error);
      res.status(500).json({ success: false, message: "Failed to get contacts" });
    }
  });

  // ADMIN: Delete Contact Submission
  app.delete("/api/admin/contacts/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const deleted = await storage.deleteContactSubmission(req.params.id);
      if (!deleted) {
        res.status(404).json({ success: false, message: "Contact submission not found" });
        return;
      }

      res.json({ success: true, message: "Contact submission deleted" });
    } catch (error) {
      console.error("Delete contact error:", error);
      res.status(500).json({ success: false, message: "Failed to delete contact" });
    }
  });

  // ADMIN: Get Promo Codes
  app.get("/api/admin/promocodes", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const promoCodes = await storage.getPromoCodes();
      res.json({ success: true, promoCodes });
    } catch (error) {
      console.error("Get promo codes error:", error);
      res.status(500).json({ success: false, message: "Failed to get promo codes" });
    }
  });

  // ADMIN: Create Promo Code
  app.post("/api/admin/promocodes", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const promoCode = await storage.createPromoCode(req.body);
      res.status(201).json({ success: true, promoCode });
    } catch (error) {
      console.error("Create promo code error:", error);
      res.status(500).json({ success: false, message: "Failed to create promo code" });
    }
  });

  // ADMIN: Update Promo Code
  app.patch("/api/admin/promocodes/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const promoCode = await storage.updatePromoCode(req.params.id, req.body);
      if (!promoCode) {
        res.status(404).json({ success: false, message: "Promo code not found" });
        return;
      }

      res.json({ success: true, promoCode });
    } catch (error) {
      console.error("Update promo code error:", error);
      res.status(500).json({ success: false, message: "Failed to update promo code" });
    }
  });

  // ADMIN: Delete Promo Code
  app.delete("/api/admin/promocodes/:id", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const deleted = await storage.deletePromoCode(req.params.id);
      if (!deleted) {
        res.status(404).json({ success: false, message: "Promo code not found" });
        return;
      }

      res.json({ success: true, message: "Promo code deleted" });
    } catch (error) {
      console.error("Delete promo code error:", error);
      res.status(500).json({ success: false, message: "Failed to delete promo code" });
    }
  });

  // ADMIN: Get Site Settings
  app.get("/api/admin/settings", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const settings = await storage.getSiteSettings();
      res.json({ success: true, settings });
    } catch (error) {
      console.error("Get settings error:", error);
      res.status(500).json({ success: false, message: "Failed to get settings" });
    }
  });

  // ADMIN: Update Site Setting
  app.put("/api/admin/settings/:key", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { value, type, description } = req.body;
      const setting = await storage.setSiteSetting(req.params.key, value, type, description);
      res.json({ success: true, setting });
    } catch (error) {
      console.error("Update setting error:", error);
      res.status(500).json({ success: false, message: "Failed to update setting" });
    }
  });

  // USER: Change Password
  app.post("/api/auth/change-password", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user) {
        res.status(404).json({ success: false, message: "User not found" });
        return;
      }

      const { currentPassword, newPassword } = req.body;

      if (!currentPassword || !newPassword) {
        res.status(400).json({ success: false, message: "Current and new passwords required" });
        return;
      }

      const isValid = await verifyPassword(currentPassword, user.passwordHash || user.password);
      if (!isValid) {
        res.status(400).json({ success: false, message: "Current password is incorrect" });
        return;
      }

      if (newPassword.length < 8) {
        res.status(400).json({ success: false, message: "Password must be at least 8 characters" });
        return;
      }

      const hashedPassword = await hashPassword(newPassword);
      await storage.updateUser(user.id, { passwordHash: hashedPassword, password: hashedPassword });

      res.json({ success: true, message: "Password changed successfully" });
    } catch (error) {
      console.error("Change password error:", error);
      res.status(500).json({ success: false, message: "Failed to change password" });
    }
  });

  // USER: Mark Notification as Read
  app.patch("/api/notifications/:id/read", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      await storage.markNotificationAsRead(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Mark notification as read error:", error);
      res.status(500).json({ success: false, message: "Failed to mark as read" });
    }
  });

  // ADMIN: Get product images
  app.get("/api/admin/products/:id/images", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const images = await storage.getProductImages(req.params.id);
      res.json({ success: true, images });
    } catch (error) {
      console.error("Get product images error:", error);
      res.status(500).json({ success: false, message: "Failed to get images" });
    }
  });

  // ADMIN: Add product image (accepts both base64 and URL)
  app.post("/api/admin/products/:id/images", async (req, res) => {
    try {
      console.log(`üì∏ [POST /api/admin/products/:id/images] Starting image upload for product: ${req.params.id}`);
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { imageUrl, imageBase64 } = req.body;
      const imageData = imageBase64 || imageUrl;
      
      if (!imageData || typeof imageData !== 'string') {
        console.error(`‚ùå [POST /api/admin/products/:id/images] No image data provided`);
        res.status(400).json({ success: false, message: "Image data required" });
        return;
      }

      console.log(`üìù [POST /api/admin/products/:id/images] Image data length: ${imageData.length} chars`);

      // Validate base64 size (max 5MB)
      if (imageData.startsWith('data:image')) {
        const base64Size = calculateBase64Size(imageData);
        console.log(`üì¶ [POST /api/admin/products/:id/images] Base64 size: ${(base64Size / 1024 / 1024).toFixed(2)}MB`);
        if (base64Size > 5 * 1024 * 1024) {
          res.status(400).json({ success: false, message: "Image too large (max 5MB)" });
          return;
        }
      }

      console.log(`üîÑ [POST /api/admin/products/:id/images] Calling storage.addProductImage()`);
      const product = await storage.addProductImage(req.params.id, imageData);
      if (!product) {
        console.error(`‚ùå [POST /api/admin/products/:id/images] Product not found`);
        res.status(404).json({ success: false, message: "Product not found" });
        return;
      }

      console.log(`üóëÔ∏è [POST /api/admin/products/:id/images] Clearing caches`);
      // Clear product caches
      cache.delete('products');
      cache.delete('products-active');
      console.log(`‚úÖ [POST /api/admin/products/:id/images] Caches cleared`);

      console.log(`‚ú® [POST /api/admin/products/:id/images] SUCCESS - returning product with ${product.images ? product.images.length : 0} images`);
      res.json({ success: true, product });
    } catch (error) {
      console.error("‚ùå Add product image error:", error);
      res.status(500).json({ success: false, message: "Failed to add image" });
    }
  });

  // ADMIN: Remove product image
  app.delete("/api/admin/products/:id/images", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { imageUrl, imageData } = req.body;
      const dataToRemove = imageData || imageUrl;
      
      if (!dataToRemove || typeof dataToRemove !== 'string') {
        res.status(400).json({ success: false, message: "Image data required" });
        return;
      }

      const product = await storage.removeProductImage(req.params.id, dataToRemove);
      if (!product) {
        res.status(404).json({ success: false, message: "Product not found" });
        return;
      }

      // Clear product caches
      cache.delete('products');
      cache.delete('products-active');

      res.json({ success: true, product });
    } catch (error) {
      console.error("Remove product image error:", error);
      res.status(500).json({ success: false, message: "Failed to remove image" });
    }
  });

  // ADMIN: Send notification to user
  app.post("/api/admin/notifications/send", async (req, res) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        res.status(401).json({ success: false, message: "Not authenticated" });
        return;
      }

      const payload = verifyAccessToken(token);
      const user = await storage.getUserById(payload.userId);
      if (!user || (user.role !== "admin" && user.role !== "superadmin")) {
        res.status(403).json({ success: false, message: "Not authorized" });
        return;
      }

      const { userId, title, message, type = "info", link } = req.body;
      
      if (!title || !message) {
        res.status(400).json({ success: false, message: "Title and message required" });
        return;
      }

      if (userId) {
        // Send to specific user
        const targetUser = await storage.getUserById(userId);
        if (!targetUser) {
          res.status(404).json({ success: false, message: "User not found" });
          return;
        }

        const notification = await storage.sendNotificationToUser(userId, {
          title: sanitizeInput(title, 200),
          message: sanitizeInput(message, 1000),
          type: sanitizeInput(type, 50),
          link: link ? sanitizeInput(link, 500) : null,
        });

        // Send email notification
        if (targetUser.email) {
          const emailHtml = `
            <div style="font-family: Arial, sans-serif; color: #333;">
              <h2 style="color: #1a1a1a; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">${escapeHtml(title)}</h2>
              <p style="margin: 15px 0; line-height: 1.6;">${escapeHtml(message).replace(/\n/g, '<br>')}</p>
              ${link ? `<p style="margin-top: 20px;"><a href="${escapeHtml(link)}" style="color: #4CAF50; text-decoration: none;">–ü–µ—Ä–µ–π—Ç–∏ ‚Üí</a></p>` : ''}
            </div>
          `;
          sendEmail(targetUser.email, title, emailHtml).catch(err => {
            console.error("Failed to send notification email:", err);
          });
        }

        res.json({ success: true, notification });
      } else {
        // Send to all users
        const notifications = await storage.sendNotificationToAllUsers({
          title: sanitizeInput(title, 200),
          message: sanitizeInput(message, 1000),
          type: sanitizeInput(type, 50),
          link: link ? sanitizeInput(link, 500) : null,
        });

        // Send email to all users
        const allUsers = await storage.getAllUsers();
        for (const targetUser of allUsers) {
          if (targetUser.email) {
            const emailHtml = `
              <div style="font-family: Arial, sans-serif; color: #333;">
                <h2 style="color: #1a1a1a; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">${escapeHtml(title)}</h2>
                <p style="margin: 15px 0; line-height: 1.6;">${escapeHtml(message).replace(/\n/g, '<br>')}</p>
                ${link ? `<p style="margin-top: 20px;"><a href="${escapeHtml(link)}" style="color: #4CAF50; text-decoration: none;">–ü–µ—Ä–µ–π—Ç–∏ ‚Üí</a></p>` : ''}
              </div>
            `;
            sendEmail(targetUser.email, title, emailHtml).catch(err => {
              console.error("Failed to send notification email:", err);
            });
          }
        }

        res.json({ success: true, count: notifications.length });
      }
    } catch (error) {
      console.error("Send notification error:", error);
      res.status(500).json({ success: false, message: "Failed to send notification" });
    }
  });

  // Register auth routes
  const httpServer = createServer(app);

  return httpServer;
}
